% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lesymap.R
\name{lesymap}
\alias{lesymap}
\title{Lesion to Symptom Mapping}
\usage{
lesymap(lesions.list, behavior, mask = NA, patchinfo = NA, method = "BM",
  correctByLesSize = "none", multipleComparison = "fdr",
  pThreshold = 0.05, flipSign = F, minSubjectPerVoxel = "10\%",
  nperm = 1000, saveDir = NA, binaryCheck = F, noPatch = F,
  showInfo = T, ...)
}
\arguments{
\item{lesions.list}{list of antsImages, or a vector of
filenames, or a single antsImage with 4 dimensions.}

\item{behavior}{vector of behavioral scores or filename
pointing to a file with a single column of numbers.}

\item{mask}{(default=NA) binary image to select the area
where analysis will be performed. If
not provided will be computed automatically
by thresholding the average lesion map at
minSubjectPerVoxel.}

\item{patchinfo}{(default=NA) an object obtained with getUniqueLesionPatches or from
a previous analyses. Useful for repetitive analysis to save time and
avoid the computation of patches each time.}

\item{method}{what tests to run, one of 'BM' (default), 'BMfast', 'ttest',
 'welch', 'regres', 'regresfast', 'regresPerm', 'sccan', 'sccanRaw'.

       \code{\link[=lsm_BM]{BM}} - Brunner-Munzel non parametric test, also
         called the Generalized Wilcoxon Test. The BM test is the
         same test used in the npm/Mricron software. See
         (see \href{https://www.ncbi.nlm.nih.gov/pubmed/17583985}{Rorden (2007)}).

       \code{\link[=lsm_BMfast]{BMfast}} - ultrafast Brunner-Munzel with compiled code.
         Requires Rcpp and RcppArmadillo packages. BMfast can be
         combined with \code{multipleComparison='FWERperm'}
         to perform permutation based thresholding in a short time.

       \code{\link[=lsm_ttest]{ttest}} - Regular single tailed t-test. Variances of groups
         are assumed to be equal. This is the test used in the voxbo
         software. Relies on t.test function in R. It is assumed
         that 0 voxels are healthy, i.e., higher behavioral scores.
         See the "alternative" parameter for inverted cases.
         (see \href{https://www.ncbi.nlm.nih.gov/pubmed/12704393}{Bates (2003)}).

       \code{\link[=lsm_ttest]{welch}} - t-test that assumes unequal variance between
         groups. Relies on t.test function in R.

       \code{\link[=lsm_regres]{regres}} - linear model between voxel values and behavior.
         Uses the lm function in R. This is equivalent to a
         t-test, but is useful when voxels are continuous, or
         when you want to know the direction of relationship
         without making assumtions. No covariates are allowed, but
         see below.

       \code{\link[=lsm_regresfast]{regresfast}} - ultrafast linear regressions with compiled code.
         Requires Rcpp and RcppArmadillo packages. You can set covariates.
         The effect of each voxel will be estimated with the formula:\cr
         \code{behavior ~ voxel + covar1 + covar2 + ...}\cr
         This method allows permutation based thresholding with
         \code{FWERperm} and \code{clusterPerm}. If covariates are used,
         permutations are performed with the Freedman-Lane method
         (see \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4010955/}{Winkler (2014)}).

       \code{\link[=lsm_regresPerm]{regresPerm}} - linear model between voxel values and behavior.
         P-values are computed through permutatons with the
         lmp function in lmPerm package.

       \code{\link[=lsm_chisq]{chisq}} - chi-square test between voxel values and behavior.
         The method is used when your behavior data are binary. Relies on the
         \code{\link[stats]{chisq.test}}
         R function and corrects individual voxel p-values with the Yates method (similar
         to the voxbo software).

       \code{\link[=lsm_chisq]{chisqPerm}} - chi-square test between voxel values and behavior.
         The method is used when your behavior data are binary. P-values are established
         through permutation tests. Relies on the \code{\link[stats]{chisq.test}} R function.

       \code{\link[=lsm_sccan]{sccan}} - sparse canonical correlations (NEW). Multivariate
         method that considers all voxels at once. By default,
         lesymap will run a lengthy procedure to determine the optimal
         sparseness value (how extensive the results should be). You
         can set \code{optimizeSparseness=FALSE} if you want to skip this
         optimization. The search for optimal sparsness provides
         a cross-validated correlation measure that shows how well
         SCCAN can predict new patients. If this correlation has
         \code{p > pThreshold}, the entire solution will be ignored and a
         NULL result will be returned. Lesymap returns normalized (0-1)
         voxel weights converted to positive; you can use \code{rawStat=TRUE}
         to retain the original voxel weights. Note that lesymap
         scales and centers both lesion and behavior data pror to
         processing (hardcoded in \link{lsm_sccan}).}

\item{correctByLesSize}{whether to correct for lesion size in the analysis.
Options are "none", "voxel", "behavior":
\itemize{
\item\code{"none"}: (default) no correction
\item\code{"voxel"}: divide voxel values by 1/sqrt(lesionsize).
   This is the method used in
   \href{https://www.ncbi.nlm.nih.gov/pubmed/25879574}{Mirman (2015)} and
   \href{https://www.ncbi.nlm.nih.gov/pubmed/25044213}{Zhang (2014)}.
   This correction works only with
   'regres' methods. Two sample comparisons
   (t-tests and Brunner-Munzel) use binary voxels
   and will ignore this correction.
\item\code{"behavior"}: residualize behavioral scores by removing
   the effect of lesion size. This works on all methods,
   but is more agressive on results.
   }}

\item{multipleComparison}{(default='fdr') method to adjust p-values.
Standard methods include \code{"holm"}, \code{"hochberg"},
\code{"hommel"}, \code{"bonferroni"}, \code{"BH"}, \code{"BY"}, \code{"fdr"}.
(see \code{\link[stats]{p.adjust}} ) \cr
Permutation methods include: \cr
\code{"FWERperm"} (permutation based family-wise threshold) is enabled
  with methods 'BMfast' and 'regresfast'. In this
  case, many analysis are run with permuted behavioral
  scores, and the peak score is recorded each time (see
  Winkler 2014). The optimal threshold is established at
  95th percentile of this distribution (or whatever pThreshold
  you choose). You can choose to use as reference another
  voxel lower in the ranks by specifying another `v` value
  (i.e., lesymap(..., v=10) will record the 10th highest voxel). \cr
\code{"clusterPerm"} (permutation based cluster correction) is enabled
  for 'regresfast'. It records the maximal
  cluster size from many random permutations of the behavior
  score and sets a cluster threshold based on that distribution.
  You must select pThreshold (voxel-wise, default=0.05) and
  clusterPermThreshold (cluster-wise, default 0.05) to achieve
  optimal with this method.}

\item{pThreshold}{(default=0.05) threshold statistics at this p-value
(after corrections or permutations)}

\item{flipSign}{logical (default=FALSE), invert the sign in the statistics image.}

\item{minSubjectPerVoxel}{(default='10\%') remove voxels/patches with lesions
in less than X subjects. Value can
be speficifed as percentage ('10\%')
or exact number of subjects (10).}

\item{nperm}{(default=1000) number of permutations to run when necessary.}

\item{saveDir}{(default=NA) save results in the specified folder.}

\item{binaryCheck}{logical (default=FALSE), make sure the lesion matrix is 0/1.}

\item{noPatch}{logical (default=FALSE), if True avoids using patch information and
will analyze all voxels. It will take longer and results will be
worse due to more multuple comparison corrections. This argument
is ignored when performing SCCAN analyses.}

\item{showInfo}{logical (default=TRUE), display time-stamped info messages}

\item{...}{arguments that will be passed down to other functions
(i.e., sparsness=0.045)}
}
\value{
The following objects are typically found in the returned list:
\itemize{
\item\code{stat.img}   - statistical map
\item\code{pval.img}   - p-values map
\item\code{zmap.img}   - zscore map
\item\code{mask.img}    - mask used for the analyses
\item\code{average.img} - map of all lesions averaged. Map is
           produced only if no mask is defined.
\item\code{callinfo} - list of details of how you called lesymap
\item\code{perm.vector} - the values obtained from each permutation
\item\code{perm.clusterThreshold} - threshold computed for cluster thresholding
\item\code{perm.FWERthresh} - threshold computed for FWERperm thresholding
\item\code{patchinfo}   - list of variables describing patch information:
    \itemize{
    \item\code{patchimg} - antsImage with the patch number each voxels belongs to
    \item\code{patchimg.samples} - antsImage mask with a single voxel per patch
    \item\code{patchimg.size} - antsImage with the patch size at each voxel
    \item\code{patchimg.mask} -  the mask within which the function will look for patches
    \item\code{npatches} - number of unique patches in the image
    \item\code{nvoxels} - total number of lesioned voxels in mask
    \item\code{patchvoxels} - vector of voxel count for each patch
    \item\code{patchvolumes} - vector of volume size for each patch
    \item\code{patchmatrix} - the lesional matrix, ready for use in analyses.
           Matrix has size NxP (N=number of subjects, P=number of
           patches)
           }
}
}
\description{
Lesymap uses univariate and multivariate methods to map
functional regions of the brain that, when lesioned,
cause specific cognitive deficits. All is required is
a set of Nifti images with the lesion of each subject
and the vector of behavioral scores. Lesions must be
already registered in template space, use `antsRegistration`
or other ANTs tools to achieve this. Lesymap will check that
lesions are in the same space before running. By default, voxels
with identical lesion patterns are grouped together in
unique patches, and analysis are run on patches.
Patch-based mapping decreases the number of multiple
comparisons and speeds up the analyses. Multivariate mapping
is performed using an optimized version of sparse canonical
correlations (SCCAN).
}
\details{
Several other parameters ccan be specified to lesymap()
which will be passed to other called fuctions. Here are
some examples:

\code{permuteNthreshold}  - (default=9) for Brunner-Munzel tests only.
   Voxels lesioned in less than this number
   of subjects will undergo permutation-based
   p-value estimation. Useful because the BM test
   is not valid when comparing groups with N < 9.
   Note, permuted BM tests require the package
   'nparcomp'.

\code{clusterPermThreshold} - threshold used to find the optimal cluster size when
   using 'clusterPerm' multiple comparison correction.

\code{alternative} - (default='greater') for two sample tests (ttests and BM).
   LESYMAP computes single tailed p-values, assuming
   that non-lesioned 0 voxels have higher behavioral scores.
   You can specify the opposite relationship with alternative='less'
   or compute two tailed p-values with alternative='two.sided'.

\code{covariates} - (default=NA) enabled for method = 'regresfast'.
   This will allow to model the effect of each voxel
   in the context of other covariates, i.e., formula
   "behavior ~ voxel + covar1 + covar2 + ...". \cr
   I,.e., lesymap(lesions,behavior, method='regresfast',
           covariates=cbind(lesionsize, age)).\cr
   If you choose permutation based thresholding with covariates, lesymap
   will use the Freedman-Lane method for extracting the unique effect of
   each voxel (see Winkler 2014, Freedman 1983)

\code{template} - antsImage or filename used for plotting the results if a saving
   directory is specified (see saveDir)

\code{v} - (default=1) which voxel to record for permutation based thresholding.
   Normally the peak voxel is used (1), but other voxels can be recorded.
   See Mirman 2017 for this approach.
}
\examples{
onefile = system.file(file.path('extdata','lesions'), 'Subject_001.nii.gz', package='LESYMAP')
niftifolder = dirname(onefile)
filenames = Sys.glob( file.path(niftifolder, 'Subject*.nii.gz'))
behavior = system.file(file.path('extdata','behavior'), 'behavior.txt', package='LESYMAP')
template = antsImageRead(system.file(file.path('extdata','template'), 'ch2.nii.gz', package='LESYMAP'))
lsm = lesymap(filenames, behavior, method = 'BMfast')
plot(template, lsm$stat.img, window.overlay = range(lsm$stat.img))

\dontrun{
# Same analysis with SCCAN
lsm = lesymap(filenames, behavior, method = 'sccan',
sparseness=0.045, optimizeSparseness=FALSE)
plot(template, lsm$stat.img, window.overlay = range(lsm$stat.img))
save.lesymap(lsm, saveDir='/home/dp/Desktop/SCCANresults')
}

}
\author{
Dorian Pustina
}
